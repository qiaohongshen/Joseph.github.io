<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="web, font-end" />










<meta name="description" content="“为往圣继绝学”">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe&#39;s Website">
<meta property="og:url" content="http://www.iwashere.cn/index.html">
<meta property="og:site_name" content="Joe&#39;s Website">
<meta property="og:description" content="“为往圣继绝学”">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe&#39;s Website">
<meta name="twitter:description" content="“为往圣继绝学”">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.iwashere.cn/"/>





  <title>Joe's Website</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Joe's Website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2018/09/30/GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/GC/" itemprop="url">JS的内存管理机制（垃圾回收机制）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T21:33:32+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>像C语言这样的高级语言一般都有底层的内存管理接口，比如 malloc()和free()。另一方面，JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。 这是错误的。</p>
</blockquote>
<h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><p>不管什么程序语言，内存生命周期基本是一致的：   </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放\归还<br>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像<code>JavaScript</code>这些高级语言中，大部分都是隐含的。</li>
</ol>
<h4 id="JS的内存分配"><a href="#JS的内存分配" class="headerlink" title="JS的内存分配"></a>JS的内存分配</h4><ol>
<li><p>值的初始化<br>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span> <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span> <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数调用分配内存<br>有些函数调用结果是分配对象内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>) <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有些方法分配新变量或者新对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span></span><br><span class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>]</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>]</span><br><span class="line"><span class="keyword">var</span> a3 = a.concat(a2)</span><br><span class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h4><blockquote>
<p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
</blockquote>
<h4 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h4><blockquote>
<p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。<br>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p>
<h4 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h4><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line">o = <span class="number">1</span>;     <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"><span class="keyword">var</span> oa = o2.a <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line">o2 = <span class="string">"yo"</span> <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line">oa = <span class="literal">null</span> <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>
<h5 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h5><p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;</span><br><span class="line">  o.a = o2 <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<p>例子：<br>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>)</span><br><span class="line">  div.circularReference = div</span><br><span class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子里，<code>myDivElement</code> 这个 DOM 元素里的 <code>circularReference</code> 属性引用了 <code>myDivElement</code>，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 <code>lotsOfData</code> 属性)，而这个数据占用的内存将永远不会被释放。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。<br>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。<br>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<h6 id="循环引用不再是问题了"><a href="#循环引用不再是问题了" class="headerlink" title="循环引用不再是问题了"></a>循环引用不再是问题了</h6><p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。</p>
<h6 id="限制-那些无法从根对象查询到的对象都将被清除"><a href="#限制-那些无法从根对象查询到的对象都将被清除" class="headerlink" title="限制: 那些无法从根对象查询到的对象都将被清除"></a>限制: 那些无法从根对象查询到的对象都将被清除</h6><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2018/04/16/browser-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/browser-cache/" itemprop="url">浏览器的缓存机制总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T20:51:02+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="浏览器缓存类型"><a href="#浏览器缓存类型" class="headerlink" title="浏览器缓存类型"></a>浏览器缓存类型</h4><p>有两种，强缓存和协商缓存</p>
<ol>
<li><p><strong>强缓存</strong>：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</p>
</li>
<li><p><strong>协商缓存</strong>：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p>
</li>
<li><p>两者的共同点是：都是从客户端缓存中读取资源；区别是：强缓存不会发请求，协商缓存会发请求。</p>
</li>
</ol>
<h4 id="缓存有关的-header"><a href="#缓存有关的-header" class="headerlink" title="缓存有关的 header"></a>缓存有关的 <strong>header</strong></h4><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ol>
<li><p><code>Expires</code>：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。</p>
</li>
<li><p><code>Cache-Control</code>：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
</li>
</ol>
<p><code>Expires</code>和<code>Cache-Control:max-age=***</code> 的作用是差不多的，区别就在于 <code>Expires</code> 是http1.0的产物，<code>Cache-Control</code>是http1.1的产物，两者同时存在的话，<code>Cache-Control</code>优先级高于<code>Expires</code>；在某些不支持HTTP1.1的环境下，<code>Expires</code>就会发挥用处。所以<code>Expires</code>其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p><code>ETag</code>和<code>If-None-Match</code>：这两个要一起说。<code>Etag</code>是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，<code>Etag</code>就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的<code>Etag</code>值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。</p>
<p><code>Last-Modified</code>和<code>If-Modified-Since</code>：这两个也要一起说。<code>Last-Modified</code>是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的<code>If-Modified-Since</code>里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p>
<p><code>ETag</code>和<code>Last-Modified</code>的作用和用法也是差不多，说一说他们的区别。</p>
<ol>
<li><p>首先在精确度上，<code>Etag</code>要优于<code>Last-Modified</code>。<code>Last-Modified</code>的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的<code>Last-Modified</code>其实并没有体现出来修改，但是<code>Etag</code>每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的<code>Last-Modified</code>也有可能不一致。</p>
</li>
<li><p>第二在性能上，<code>Etag</code>要逊于<code>Last-Modified</code>，毕竟<code>Last-Modified</code>只需要记录时间，而<code>Etag</code>需要服务器通过算法来计算出一个hash值。</p>
</li>
<li><p>第三在优先级上，服务器校验优先考虑<code>Etag</code>。</p>
</li>
</ol>
<h4 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h4><ol>
<li>浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</li>
<li>下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过<code>cache-control</code>设置的<code>max-age</code>，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用<code>expires</code>判断是否过期）；如果时间过期，则向服务器发送header带有<code>If-None-Match</code>和<code>If-Modified-Since</code>的请求；</li>
<li>服务器收到请求后，优先根据<code>Etag</code>的值判断被请求的文件有没有做修改，<code>Etag</code>值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的<code>Etag</code>值并返回200；</li>
<li>如果服务器收到的请求没有<code>Etag</code>值，则将<code>If-Modified-Since</code>和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的<code>last-modified</code>和文件并返回200。</li>
</ol>
<h4 id="用户行为对浏览器缓存的控制"><a href="#用户行为对浏览器缓存的控制" class="headerlink" title="用户行为对浏览器缓存的控制"></a>用户行为对浏览器缓存的控制</h4><ol>
<li>地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li>
<li>F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；</li>
<li>ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2018/01/19/jQuery&Vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/19/jQuery&Vue/" itemprop="url">关于jQuery和Vue两者技术架构的比较分析报告</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T12:25:11+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于jQuery和Vue两者技术架构的比较分析报告"><a href="#关于jQuery和Vue两者技术架构的比较分析报告" class="headerlink" title="关于jQuery和Vue两者技术架构的比较分析报告"></a>关于jQuery和Vue两者技术架构的比较分析报告</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><blockquote>
<p>jQuery已经过时了。略做点补充：Zepto也是过时货了。还有Underscore/Lodash等，也是过时了。但是过时不代表你就一定不可以再用，或者要从现有项目中清除抛弃掉。项目维护和管理本身是另一回事情，并不是完全由技术因素决定的。看一下前两点，1. 新的DOM标准（借鉴jQuery）加入了许多新的方法，覆盖了绝大部分use cases；2. 目前主流浏览器的兼容性已经大幅提高，且因为都是Evergreen browsers了，所以以后也不太会出现严重的兼容性问题了；此外新标准比以往要更详尽清晰，出现不一致和bug的机率也小了；实际上这前两点也不是一蹴而就的，而是一直在改进。比如原生querySelector API普及之后，才出现了Zepto。只不过这两年发展加速，以至于Zepto还没取代jQuery，就要一起过时了。（贺师俊hax）</p>
</blockquote>
<h3 id="jQuery的核心价值"><a href="#jQuery的核心价值" class="headerlink" title="jQuery的核心价值"></a>jQuery的核心价值</h3><ol>
<li>发扬光大了$和CSS选择器的天才idea（尽管都不是发明者）</li>
<li>处理浏览器的兼容性问题和各种bug</li>
<li>链式调用为核心的DSL（此为jQuery独创）</li>
<li>基于jQuery的生态（大量插件，各种工具如IDE也对其有良好支持）</li>
</ol>
<h3 id="jQuery的劣势"><a href="#jQuery的劣势" class="headerlink" title="jQuery的劣势"></a>jQuery的劣势</h3><ol>
<li>完整的jQuery体积太大。对于一些比较小的项目确实可以做到快速开发，但是现在的jQuery太臃肿了，有很多用不到的功能。所以现在有了很多精简jQuery的项目。另外就是全DOM操作，钩子往往会依赖标签，如果依赖jQuery来搭建页面的话（比如后台输出json，然后jQuery loop一个列表出来），维护上会有困难。如果一改页面结构，很多依赖标签的选择器，一改起来js那块就得跟着大改。还有就是jQuery的代码改起来不容易，如果真有项目特殊需求，要改一下jQuery代码来用就显得很麻烦。</li>
<li>不能向后兼容。每一个新版本不能兼容早期的版本。举例来说，有些新版本不再支持某些selector，新版jQuery却没有保留对它们的支持，而只是简单的将其移除。这可能会影响到开发者已经编写好的代码或插件。</li>
<li>对数据的处理有很多不便利的地方，容易导致高耦合度。</li>
</ol>
<h3 id="jQuery的适用场景"><a href="#jQuery的适用场景" class="headerlink" title="jQuery的适用场景"></a>jQuery的适用场景</h3><p>在过去的前端开发中，jQuery几乎会出现在任何大大小小的项目中，不论是类MS，还是电商，还是各类门户网站，都少不了jQuery的身影，可以说在之前的前端开发中，jQuery更是一种“标准”。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><blockquote>
<p>讲Vue之前就讲MVVM吧（Vue的架构模式就是MVVM）</p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>2008年，V8 引擎随 Chrome 浏览器横空出世，JavaScript 这门通用的 Web 脚本语言的执行效率得到质的提升。 V8 引擎的出现，注定是 JavaScript 发展史上一个光辉的里程碑。它的出现，让当时研究高性能服务器开发、长时间一筹莫展的 <a href="http://tinyclouds.org/" target="_blank" rel="external">Ryan Dahl</a> 有了新的、合适的选择，不久，在2009年的柏林的 JSConf 大会上，基于 JavaScript 的服务端项目 Node.js 正式对外发布。Node.js 的发布，不仅为开发者带来了一个高性能的服务器，还很大程度上推动了前端的工程化，带来了前端的大繁荣。与此同时，因为 JavaScript 执行效率的巨大提升，越来越多的业务逻辑开始在浏览器端实现，前端逻辑越来越重，前端架构随之提上日程。于是，我们谈论的主角，MVVM 模式，走进了 Web 前端的架构设计中。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。它萌芽于2005年微软推出的基于 Windows 的用户界面框架 WPF ，前端最早的 MVVM 框架 knockout在2010年发布。当前最流行了MVVM 框架 Vue 的2.0版本在2016年5月发布。</p>
<p>一句话总结 Web 前端 MVVM：操作数据，就是操作视图，就是操作 DOM（所以无须操作 DOM ）。</p>
<p>无须操作 DOM ！借助 MVVM 框架，开发者只需完成包含 <strong>声明绑定</strong> 的视图模板，编写 ViewModel 中业务数据变更逻辑，View 层则完全实现了自动化。这将极大的降低前端应用的操作复杂度、极大提升应用的开发效率。MVVM 最标志性的特性就是 <strong>数据绑定</strong> ，MVVM 的核心理念就是通过 <strong>声明式的数据绑定</strong> 来实现 View 层和其他层的分离。完全解耦 View 层这种理念，也使得 Web 前端的单元测试用例编写变得更容易。</p>
<p>MVVM，说到底还是一种分层架构。它的分层如下：</p>
<ul>
<li>Model: 域模型，用于持久化</li>
<li>View: 作为视图模板存在</li>
<li>ViewModel: 作为视图的模型，为视图服务</li>
</ul>
<h4 id="Model-层"><a href="#Model-层" class="headerlink" title="Model 层"></a>Model 层</h4><p>Model 层，对应数据层的域模型，它主要做<code>域模型的同步</code>。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。</p>
<h4 id="View-层"><a href="#View-层" class="headerlink" title="View 层"></a>View 层</h4><p>View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 <strong>数据绑定的声明</strong>、 <strong>指令的声明</strong>、 <strong>事件绑定的声明</strong>。</p>
<h4 id="ViewModel-层"><a href="#ViewModel-层" class="headerlink" title="ViewModel 层"></a>ViewModel 层</h4><p>ViewModel 层把 View 需要的层数据暴露，并对 View 层的 <strong>数据绑定声明</strong>、 <strong>指令声明</strong>、 <strong>事件绑定声明</strong> 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。</p>
<h4 id="前端-MVVM-图示"><a href="#前端-MVVM-图示" class="headerlink" title="前端 MVVM 图示"></a>前端 MVVM 图示</h4><p><img src="https://raw.githubusercontent.com/X-Jray/blog/master/assets/mvvm.png" alt="mvvm"></p>
<p>如图所示，在前端 MVVM 框架中，往往没有清晰、独立的 Model 层。在实际业务开发中，我们通常按 <strong>Web Component</strong> 规范来组件化的开发应用，Model 层的域模型往往分散在在一个或几个 Component 的 ViewModel 层，而 ViewModel 层也会引入一些 View 层相关的中间状态，目的就是为了更好的为 View 层服务。</p>
<p>开发者在 View 层的视图模板中声明 <strong>数据绑定</strong>、 <strong>事件绑定</strong> 后，在 ViewModel 中进行业务逻辑的 <strong>数据</strong> 处理。事件触发后，ViewModel 中 <strong>数据</strong> 变更， View 层自动更新。因为 MVVM 框架的引入，开发者只需关注业务逻辑、完成数据抽象、聚焦数据，MVVM 的视图引擎会帮你搞定 View。因为数据驱动，一切变得更加简单。</p>
<h3 id="MVVM框架的工作-优势"><a href="#MVVM框架的工作-优势" class="headerlink" title="MVVM框架的工作(优势)"></a>MVVM框架的工作(优势)</h3><p>不可置否，MVVM 框架极大的提升了应用的开发效率。It’s amazing！But，MVVM 框架到底做了什么？</p>
<ul>
<li>视图引擎</li>
</ul>
<p>视图引擎：我是视图引擎，我为 View 层作为视图模板提供强力支持，开发者，你们不需要操作 DOM ，丢给我来做！</p>
<ul>
<li>数据存取器</li>
</ul>
<p>数据存取器：我是数据存取器，我可以通过 <code>Object.defineProperty()</code> API 轻松定义，或通过自行封装存取函数的方式曲线完成。我的内部往往封装了 <strong>发布/订阅模式</strong>，以此来完成对数据的监听、数据变更时通知更新。我是 <strong>数据绑定</strong> 实现的基础。</p>
<ul>
<li>组件机制</li>
</ul>
<p>组件机制：我是组件机制。有追求的开发者往往希望按照面向未来的组件标准 － <strong>Web Components</strong> 的方式开发，我是为了满足你的追求而生。MVVM 框架提供组件的定义、继承、生命周期、组件间通信机制，为开发者面向未来开发点亮明灯。</p>
<ul>
<li>more…</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>MVVM架构型模式的兴起，实现了前后端真正的职责分离，在提高开发效率的同时，也存在一些不足之处。</p>
<ol>
<li>比如说SEO：网站的前后分离架构越来越得到开发者们的喜爱与认可， 后端只提供数据接口、业务逻辑与持久化服务，而视图、控制与渲染则交给前端。 因此，越来越多的网站从后端渲染变成了前端渲染，而由此带来的直接问题就是各大搜索引擎爬虫对于前端渲染的页面（ 动态内容 ）还无法比较完善的爬取，这就导致了网站的内容无法被搜索引擎收录，直接影响网站流量与曝光度。但是，在如今的Vue中可以使用服务端渲染或者预渲染（SSR or Prerendering）来解决seo的问题，更有SSR开源框架Nuxt的支持。所以，MVVM是应时代产物，在逐步变得更加完善。</li>
<li>在兼容性方面，Vue由于数据操作API方法的选择的原因，所以并没有做到兼容IE8及其以下版本。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>可以说前后端分离随着趋势已经形成一种标准，MVVM设计模式的开发框架（Vue）适用任何场景的开发（低版本IE除外）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>jQuery是直接来操作DOM的，凭借简化后的API直接和DOM对话（优异的兼容性）；<br>Vue是直接来操作数据的，拿数据说话。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/11/22/null&undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/null&undefined/" itemprop="url">JavaScript中null和undefined的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T17:09:09+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很多人都喜欢问这个问题，然而问这个问题的人本身也不太懂，所以今天拿出来剖析一下这个事情。</p>
<h2 id="一、等价性"><a href="#一、等价性" class="headerlink" title="一、等价性"></a>一、等价性</h2><p>在JavaScript中，将一个变量赋值为null或undefined，几乎没区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>null和undefined在if语句中，都会被自动转为false，相等运算符结果是两者相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'null is false'</span>); <span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>); <span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="二、历史原因"><a href="#二、历史原因" class="headerlink" title="二、历史原因"></a>二、历史原因</h2><p>1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。<br>根据C语言的传统，null被设计成可以自动转为0。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。<br>首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。<br>其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。<br>因此，Brendan Eich又设计了一个undefined。</p>
<h2 id="三、设计之初"><a href="#三、设计之初" class="headerlink" title="三、设计之初"></a>三、设计之初</h2><p>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、用法"><a href="#四、用法" class="headerlink" title="四、用法"></a>四、用法</h2><p>上面这样的区分，在实践中很快就被证明不可行。目前，null和undefined基本是同义的，只有一些细微的差别。</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<blockquote>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<blockquote>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Over.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/11/10/other_git_account/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/other_git_account/" itemprop="url">如何在同一客户端部署多个git帐号(多账户下设置ssh keys)？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T14:55:03+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>有些事情总是无法避免的，要是你没有遇到过这个问题，你可能不知道我在说什么。就比如说我自己的一些开源项目放在github上，然而公司的项目是部署在gitlab上。我们使用git进行版本管理即与远程服务器做到同步,但是问题来了：默认情况下每个账户生成的秘钥位置和名称都是相同的，这样后生成的秘钥就会覆盖前面的秘钥导致其失效。解决的办法就是在生成后一个秘钥的时候对其重新命名，以避免冲突，同时将不同的秘钥配置到相对应的Host上面，这样在访问不同的远程仓库时调用不同的key,冲突也就解决了。</p>
</blockquote>
<h2 id="Mac环境为例"><a href="#Mac环境为例" class="headerlink" title="Mac环境为例"></a>Mac环境为例</h2><h3 id="生成gitlab密钥"><a href="#生成gitlab密钥" class="headerlink" title="生成gitlab密钥"></a>生成gitlab密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;注册gitlab的邮箱&quot; -b 4096</span><br></pre></td></tr></table></figure>
<p>使用默认名称，然后不设置密码，回车直接跳过。<br>查看 <code>.ssh</code> 目录，可以看到生成的公钥和私钥，名称分别为 <code>id_rsa.pub</code> 和 <code>id_rsa</code></p>
<p>使用命令 <code>cat ~/.ssh/id_rsa.pub</code> 可以查看公钥内容，这个就是gitlab下ssh keys下需要添加的内容。</p>
<h3 id="生成github密钥"><a href="#生成github密钥" class="headerlink" title="生成github密钥"></a>生成github密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;注册github的邮箱&quot; -b 4096</span><br></pre></td></tr></table></figure>
<p>这次不使用默认名称，要对生成定的秘钥进行重命名，这里重命名为 <code>id_rsa_github</code> , 同样不设置密码。<br>查看 <code>.ssh</code> 目录，可以看到生成的公钥和私钥，名称分别为 <code>id_rsa_github.pub</code> 和 <code>id_rsa_github</code></p>
<p>使用命令<code>cat ~/.ssh/id_rsa_github.pub</code>可以查看公钥内容，这个就是github下ssh keys下需要添加的内容。</p>
<h3 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h3><p>在 <code>.ssh/</code> 目录下新建config文件：<code>touch config</code>，通过vim进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># gitlab</span><br><span class="line">Host gitlab</span><br><span class="line">    HostName gitlab.foo.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure></p>
<p>然后<code>:wq</code> (vim命令，保存退出)</p>
<p><code>Host</code>对应的名称是一个别名，命名可以随意，用来进行远程连接。<code>HostName</code>和<code>IdentityFile</code>是各自主机名称以及对应的秘钥文件。</p>
<hr>
<p>配置完毕。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/09/25/caller&callee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/25/caller&callee/" itemprop="url">还有人在问你caller和callee的区别?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-25T15:18:21+08:00">
                2017-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很搞笑，首先我不知道面试官还会问这种问题，意义何在？let me give him a fu… lesson?</p>
<h3 id="Function-caller"><a href="#Function-caller" class="headerlink" title="Function.caller"></a>Function.caller</h3><p>返回调用指定函数的函数。<br>如果一个函数f是在全局作用域内被调用的,则f.caller为null,相反,如果一个函数是在另外一个函数作用域内被调用的,则f.caller指向调用它的那个函数。<br>该属性的常用形式<code>arguments.callee.caller</code>替代了被废弃的 <code>arguments.caller</code><br>什么？ 被废弃了？<br>是的，废弃的 <code>arguments.caller</code> 属性原先用在函数执行的时候调用自身。本属性已被移除且不再有用。<br><code>arguments.caller</code> 已经不可使用了，但是你还可以使用 <code>Function.caller</code>，但是该特性也是非标准的，尽量不要在生产环境中使用它！</p>
<p>下例演示了arguments.caller属性的作用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whoCalled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">arguments</span>.caller == <span class="literal">null</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'该函数在全局作用域内被调用.'</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.caller + <span class="string">'调用了我!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下例用来得出一个函数是被谁调用的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (myFunc.caller == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"该函数在全局作用域内被调用!"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"调用我的是函数是"</span> + myFunc.caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h3><p>不用鸡冻，这个东西也好不到哪儿去，<br>callee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也称为“匿名函数”)内。<br>但是，看这个警告：</p>
<blockquote>
<p>在严格模式下，第5版 ECMAScript (<strong>ES5</strong>) 禁止使用 arguments.callee()。<br>当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明。</p>
</blockquote>
<h5 id="为什么-arguments-callee-从ES5严格模式中删除了？"><a href="#为什么-arguments-callee-从ES5严格模式中删除了？" class="headerlink" title="为什么 arguments.callee 从ES5严格模式中删除了？"></a>为什么 arguments.callee 从ES5严格模式中删除了？</h5><p>早期版本的 JavaScript不允许使用命名函数表达式，出于这样的原因, 你不能创建一个递归函数表达式。<br>例如，下边这个语法就是行的通的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(factorial);</span><br></pre></td></tr></table></figure></p>
<p>但是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : <span class="comment">/* 这里写什么? */</span> (n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个不行。为了解决这个问题， arguments.callee 添加进来了。然后你可以这么做<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>然而，这实际上是一个非常糟糕的解决方案，因为这 (以及其它的 arguments, callee, 和 caller 问题) 使得在通常的情况（你可以通过调试一些个别例子去实现它，但即使最好的代码是最理想的，你也没必要去检查调试它）不可能实现内联和尾递归。另外一个主要原因是递归调用会获取到一个不同的 this 值，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sillyFunction = <span class="function"><span class="keyword">function</span> (<span class="params">recursed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recursed) &#123; <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(<span class="literal">true</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> !== global) &#123;</span><br><span class="line">        alert(<span class="string">"This is: "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"This is the global"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sillyFunction();</span><br></pre></td></tr></table></figure></p>
<p>ECMAScript 3（es3?哈哈） 通过允许命名函数表达式解决这些问题。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : factorial(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这有很多好处：</p>
<ul>
<li>该函数可以像代码内部的任何其他函数一样被调用</li>
<li>它不会在外部作用域中创建一个变量 (除了 IE 8 及以下)</li>
<li>它具有比访问arguments对象更好的性能</li>
</ul>
<p>另外一个被废弃的特性是 arguments.callee.caller，具体点说则是 Function.caller。为什么? 额，在任何一个时间点，你能在堆栈中找到任何函数的最深层的调用者，也正如我在上面提到的，在调用堆栈有一个单一重大影响：不可能做大量的优化，或者有更多更多的困难。比如，如果你不能保证一个函数 f 不会调用一个未知函数，它就绝不可能是内联函数 f。基本上这意味着内联代码中积累了大量防卫代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">a, b, c, d, e</span>) </span>&#123; <span class="keyword">return</span> a ? b * c : d * e; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 JavaScript 解释器不能保证所有提供的参数数量在被调用的时候都存在，那么它需要在行内代码插入检查，或者不能内联这个函数。现在在这个特殊例子里一个智能的解释器应该能重排检查而更优，并检查任何将不用到的值。然而在许多的情况里那是不可能的，也因此它不能够内联。</p>
<h5 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h5><h6 id="在匿名递归函数中使用-arguments-callee"><a href="#在匿名递归函数中使用-arguments-callee" class="headerlink" title="在匿名递归函数中使用 arguments.callee"></a>在匿名递归函数中使用 arguments.callee</h6><p>递归函数必须能够引用它本身。很典型的，函数通过自己的名字调用自己。然而，匿名函数 (通过 函数表达式 或者 函数构造器 创建) 没有名称。因此如果没有可访问的变量指向该函数，唯一能引用它的方式就是通过 arguments.callee。</p>
<p>下面的例子定义了一个函数，按流程，定义并返回了一个阶乘函数。该例并不是很实用，并且几乎都能够用命名函数表达式实现同样结果的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = create()(<span class="number">5</span>); <span class="comment">// 返回120 (5 * 4 * 3 * 2 * 1)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="没有替代方案的-arguments-callee"><a href="#没有替代方案的-arguments-callee" class="headerlink" title="没有替代方案的 arguments.callee"></a>没有替代方案的 arguments.callee</h6><p>下面的例子是没有可以替代 arguments.callee的方案的，因此弃用它时会产生一个BUG (参看 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=725398" target="_blank" rel="external">bug 725398</a>):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">sIdentity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oPerson = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(arguments.callee.identity);"</span>);</span><br><span class="line">    oPerson.identity = sIdentity;</span><br><span class="line">    <span class="keyword">return</span> oPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> joe = createPerson(<span class="string">"Joseph"</span>);</span><br><span class="line"></span><br><span class="line">joe();</span><br></pre></td></tr></table></figure></p>
<p>利用命名函数表达式也可以实现上述例子的同样效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">identity</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.identity);</span><br><span class="line">    &#125;</span><br><span class="line">    Person.identity = identity;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> joe = createPerson(<span class="string">"Joseph"</span>);</span><br><span class="line"></span><br><span class="line">joe(); <span class="comment">//Joseph</span></span><br></pre></td></tr></table></figure></p>
<p>Over.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/08/24/cross-origin-at-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/cross-origin-at-server/" itemprop="url">服务端跨域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T18:49:30+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、反向代理服务器"><a href="#一、反向代理服务器" class="headerlink" title="一、反向代理服务器"></a>一、反向代理服务器</h2><p>基础思想很简单，将你的服务器配置成 <strong>需要跨域获取的资源的</strong> 反向代理服务器。<br>也就是说，将其他域名的资源映射到你自己的域名之下，这样浏览器就认为他们是同源的。<br>用大家钟爱的 Apache2 来举个例子：<br>首先启用两个模块 proxy 和 proxy_http 来开启代理功能：</p>
<blockquote>
<p>sudo a2enmod proxysudo a2enmod proxy_http</p>
</blockquote>
<p>然后在配置文件里面写入：</p>
<blockquote>
<p>ProxyPass “/foo” “<a href="http://foo.example.com/bar&quot;ProxyPassReverse" target="_blank" rel="external">http://foo.example.com/bar&quot;ProxyPassReverse</a> “/foo” “<a href="http://foo.example.com/bar" target="_blank" rel="external">http://foo.example.com/bar</a>“</p>
</blockquote>
<p>ProxyPass: 远程服务器在本地服务器的映射。（上面的例子将 <a href="http://foo.example.com/bar映射为" target="_blank" rel="external">http://foo.example.com/bar映射为</a> /foo）</p>
<p>ProxyPassReverse: 配置 Apache2 在 HTTP 跳转时调整 Location, Content-Location 和 URI headers的值，防止反向代理被绕开。</p>
<p>重启 Apache2：</p>
<blockquote>
<p>sudo service apache2 restart</p>
</blockquote>
<p>大功告成，这样我们请求 /foo就会得到 <a href="http://foo.example.com/bar的内容了。" target="_blank" rel="external">http://foo.example.com/bar的内容了。</a><br>这种方法其实不太常用，机智的读者就会发现，每一个资源都要到自己的服务器配置，每次配置都还要重启。</p>
<h2 id="二、CORS"><a href="#二、CORS" class="headerlink" title="二、CORS"></a>二、CORS</h2><p>Cross-Origin Resource Sharing 是 W3C 推出的一种跨站资源获取的机制。</p>
<h6 id="首先我们来看一下浏览器的支持情况："><a href="#首先我们来看一下浏览器的支持情况：" class="headerlink" title="首先我们来看一下浏览器的支持情况："></a>首先我们来看一下浏览器的支持情况：</h6><table>
<thead>
<tr>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>3.5</td>
<td>8 &amp; 9, 10</td>
<td>12</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>移动端的浏览器对这种方法的支持比较完善。现在我们看到了，如果不需要兼容 IE6、7的话，就可以使用这种方法。<br>这种跨域方案主要的思想是：服务器 <strong>在响应头中设置相应的选项</strong>，浏览器如果支持这种方法的话就会将这种跨站资源请求视为合法，进而获取资源。<br>可以设置的响应头信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure></p>
<p>origin: 被允许跨域访问这个资源的网站，* 代表全部网站。浏览器会检测这个参数，如果符合要求，才会去获取资源。<br>举个例子，允许 <a href="http://qiaohongshen.github.io/foo来跨域访问这个资源：" target="_blank" rel="external">http://qiaohongshen.github.io/foo来跨域访问这个资源：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://jasonkid.github.io/fezone</span><br><span class="line">Access-Control-Allow-Credentials</span><br><span class="line">Access-Control-Allow-Credentials: true | false</span><br></pre></td></tr></table></figure></p>
<p>表示是否允许浏览器携带 Cookie 来访问这个资源。这个属性要和 XMLHttpRequest 的 withCredentials属性来配合使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://foo.other/resources/credentialed-content/'</span>;</span><br><span class="line"><span class="keyword">if</span>(xhr) &#123;</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 设置带有 Cookie 的资源请求</span></span><br><span class="line">  xhr.onreadystatechange = handler;</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>能够成功使用带有 Cookie 的资源请求需要满足以下几个条件：</p>
<ol>
<li>XMLHttpRequest</li>
<li>对象中指定了 withCredentials = true</li>
<li>服务器响应头中 Access-Control-Allow-Credentials: true</li>
<li>服务器响应头中 Access-Control-Allow-Origin不能为 *</li>
</ol>
<p>以下选项主要是安全性配置的问题，主要是服务器的配置问题了，就不展开介绍了：</p>
<ul>
<li>Access-Control-Expose-Headers</li>
<li>Access-Control-Allow-Methods</li>
<li>Access-Control-Allow-Headers</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/08/01/cross-origin-at-front-end/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/cross-origin-at-front-end/" itemprop="url">再谈前端跨域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T01:29:45+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h4><p>首先要介绍的跨域方法必然是 JSONP。<br>现在你想要获取其他网站上的 JavaScript 脚本，你非常高兴的使XMLHttpRequest 对象来获取。但是浏览器一点儿也不配合你，无情的弹出了下面的错误信息：</p>
<blockquote>
<p>XMLHttpRequest cannot load <a href="http://x.com/main.dat" target="_blank" rel="external">http://x.com/main.dat</a>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://y.com" target="_blank" rel="external">http://y.com</a>‘ is therefore not allowed access.</p>
</blockquote>
<p>你心里肯定会想，我难道要用后台做个爬虫来获取这个数据吗？！为了避免这种事情发生，JSONP 就派上用场了。<br><code>&lt;script&gt;</code>标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件，而并不要求同源。所以 JSONP 的理念就是，我和服务端约定好一个函数名，当我请求文件的时候，服务端返回一段 JavaScript。这段 JavaScript 调用了我们约定好的函数，并且将数据当做参数传入。非常巧合的一点（其实并不是），JSON 的数据格式和JavaScript 语言里对象的格式正好相同。所以在我们约定的函数里面可以直接使用这个对象。光说不练假把式，让我们来看一个例子：<br>你需要获取数据的页面 index.html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">   </span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getWeather</span>(<span class="params">data</span>) </span>&#123;       </span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://x.y.com/xx.js"</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://x.y.com/xx.js" target="_blank" rel="external">http://x.y.com/xx.js</a> 文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getWeather(&#123;</span><br><span class="line">  <span class="string">"城市"</span>: <span class="string">"北京"</span>,</span><br><span class="line">  <span class="string">"天气"</span>: <span class="string">"大雾"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在我们定义了 getWeather(data)这个函数后，直接载入了 xx.js。在这个脚本中，执行了 getWeather函数，并传入了一个对象。然后我们在这个函数中将这个对象输出到 console 中。</p>
<h6 id="这就是整个-JSONP-的流程。"><a href="#这就是整个-JSONP-的流程。" class="headerlink" title="这就是整个 JSONP 的流程。"></a>这就是整个 JSONP 的流程。</h6><h4 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2. document.domain"></a>2. document.domain</h4><p>使用条件：</p>
<ol>
<li>有其他页面 window对象的引用</li>
<li>二级域名相同</li>
<li>协议相同</li>
<li>端口相同</li>
</ol>
<p><code>document.domain</code>默认的值是整个域名，所以即使两个域名的二级域名一样，那么他们的 document.domain也不一样。使用方法就是将符合上述条件页面的 <code>document.domain</code>设置为同样的二级域名。这样我们就可以使用其他页面的 window对象引用做我们想做的任何事情了。<br><strong>补充知识：</strong><br>x.one.example.com 和 y.one.example.com 可以将 document.domain设置为 one.example.com，也可以设置为example.com。document.domain只能设置为当前域名的一个后缀，并且包括二级域名或以上（.edu.cn这种整个算顶级域名）。我们直接操刀演示，用两个网站 <a href="http://wenku.baidu.com/" target="_blank" rel="external">http://wenku.baidu.com/</a> 和<a href="http://zhidao.baidu.com/。这两个网站都是" target="_blank" rel="external">http://zhidao.baidu.com/。这两个网站都是</a> http 协议，端口都是 80， 且二级域名都是 baidu.com。打开<a href="http://wenku.baidu.com/，在" target="_blank" rel="external">http://wenku.baidu.com/，在</a> console 中输入代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'baidu.com'</span>;</span><br><span class="line"><span class="keyword">var</span> otherWindow = <span class="built_in">window</span>.open(<span class="string">'http://zhidao.baidu.com/'</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们现在已经发现百度知道的网页已经打开了，在百度知道网页的 console 中输入以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'baidu.com'</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在回到百度文库的网页，我们就可以使用百度知道网页的 window对象来操作百度知道的网页了。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = otherWindow.document.getElementsByTagName(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子的使用方法并不常见，但是非常详细的说明了这种方法的原理。这种方法主要用在控制 <code>&lt;iframe&gt;</code>的情况中。<br>比如我的页面(<a href="http://one.example.com/index.html)中内嵌了一个" target="_blank" rel="external">http://one.example.com/index.html)中内嵌了一个</a> <code>&lt;iframe&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://two.example.com/iframe.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在 iframe.html 中使用 JavaScript 将 document.domain设置好，也就是 example.com。在 index.html 执行以下脚本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span><br><span class="line">iframe.contentDocument; <span class="comment">// iframe的 document 对象</span></span><br><span class="line">iframe.contentWindow; <span class="comment">// iframe的 window 对象</span></span><br></pre></td></tr></table></figure></p>
<p>这样，我们就可以获得对iframe的完全控制权了。</p>
<p><strong>补充知识：</strong><br>当两个页面不做任何处理，但是使用了iframe或者 window.open() 得到了某个页面的 window 对象的引用，我们可以直接访问的属性有哪些？</p>
<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>window.blur</td>
</tr>
<tr>
<td>window.close</td>
</tr>
<tr>
<td>window.focus</td>
</tr>
<tr>
<td>window.postMessage</td>
</tr>
<tr>
<td>window.location.replace</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>window.closed</td>
<td>只读</td>
</tr>
<tr>
<td>window.frames</td>
<td>只读</td>
</tr>
<tr>
<td>window.length</td>
<td>只读</td>
</tr>
<tr>
<td>window.location.href</td>
<td>只写</td>
</tr>
<tr>
<td>window.opener</td>
<td>只读</td>
</tr>
<tr>
<td>window.parent</td>
<td>只读</td>
</tr>
<tr>
<td>window.self</td>
<td>只读</td>
</tr>
<tr>
<td>window.top</td>
<td>只读</td>
</tr>
<tr>
<td>window.window</td>
<td>只读</td>
</tr>
</tbody>
</table>
<h4 id="3-window-name"><a href="#3-window-name" class="headerlink" title="3. window.name"></a>3. window.name</h4><p>我们来看以下一个场景：<br>随意打开一个页面，输入以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">"My window's name"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.qq.com/"</span>;</span><br></pre></td></tr></table></figure></p>
<p>再检测 window.name :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name; <span class="comment">// My window's name</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，如果在一个标签里面跳转网页的话，我们的 window.name是不会改变的。基于这个思想，我们可以在某个页面设置好 window.name的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name了。由于安全原因，浏览器始终会保持 window.name 是 string类型。这个方法也可以应用到与 <code>&lt;iframe&gt;</code> 的交互上来。我的页面(<a href="http://one.example.com/index.html)中内嵌了一个" target="_blank" rel="external">http://one.example.com/index.html)中内嵌了一个</a> <code>&lt;iframe&gt;</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://omg.com/iframe.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 iframe.html 中设置好了 window.name为我们要传递的字符串。我们在 index.html 中写了下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">  data = iframe.contentWindow.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定睛一看，为毛线报错？细心的读者们肯定已经发现了，两个页面完全不同源啊！由于 window.name 不随着 URL 的跳转而改变，所以我们使用一个暗黑技术来解决这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    data = iframe.contentWindow.name;    </span><br><span class="line">  &#125;   </span><br><span class="line">   iframe.src = <span class="string">'about:blank'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者将里面的 about:blank 替换成某个同源页面（最好是空页面，减少加载时间）。<br><strong>补充知识：</strong><br>about:blank，javascript: 和 data:中的内容，继承了载入他们的页面的源。<br>这种方法与 document.domain方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string类型的数据。</p>
<h4 id="4-HTML5-postMessage"><a href="#4-HTML5-postMessage" class="headerlink" title="4. [HTML5] postMessage"></a>4. [HTML5] postMessage</h4><p>在 HTML5 中， window 对象增加了一个非常有用的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowObj.postMessage(message, targetOrigin);</span><br></pre></td></tr></table></figure></p>
<p>windowObj: 接受消息的 Window 对象。<br>message: 在最新的浏览器中可以是对象。<br>targetOrigin: 目标的源，* 表示任意。</p>
<p>这个方法非常强大，无视协议，端口，域名的不同。<br>下面是烤熟的栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> windowObj = <span class="built_in">window</span>; <span class="comment">// 可以是其他的 Window 对象的引用</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="literal">null</span>;</span><br><span class="line">addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;   </span><br><span class="line">  <span class="keyword">if</span>(e.origin == <span class="string">'http://qiaohongshen.github.io/foo'</span>) &#123;      </span><br><span class="line">    data = e.data;</span><br><span class="line">    e.source.postMessage(<span class="string">'Got it!'</span>, <span class="string">'*'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>message事件就是用来接收 postMessage发送过来的请求的。函数参数的属性有以下几个：<br>origin: 发送消息的 window的源。<br>data: 数据。<br>source: 发送消息的 Window对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/07/29/vue2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/29/vue2/" itemprop="url">《Vue随笔》 （二）组件之间的数据传递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T15:57:19+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Vue 的组件作用域都是孤立的，不允许在子组件的模板内直接引用父组件的数据。必须使用特定的方法才能实现组件之间的数据传递。</p>
<p>首先用 vue-cli 创建一个项目，其中 App.vue 是父组件，components 文件夹下都是子组件。<br><img src="http://upload-images.jianshu.io/upload_images/2048384-cf72f7519c353e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project tree"></p>
<h3 id="一、父组件向子组件传递数据"><a href="#一、父组件向子组件传递数据" class="headerlink" title="一、父组件向子组件传递数据"></a>一、父组件向子组件传递数据</h3><p>在 Vue 中，可以使用props向子组件传递数据。</p>
<h4 id="子组件部分："><a href="#子组件部分：" class="headerlink" title="子组件部分："></a>子组件部分：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2048384-cc801dc4ecd19e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="child component"></p>
<p>这是 header.vue 的 HTML 部分，logo 是在 data 中定义的变量。</p>
<p>如果需要从父组件获取 logo 的值，就需要使用props: [‘logo’]<br><img src="http://upload-images.jianshu.io/upload_images/2048384-8be2da0f269a35fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c com"></p>
<p>在 props 中添加了元素之后，就不需要在 data 中再添加变量了</p>
<h4 id="父组件部分："><a href="#父组件部分：" class="headerlink" title="父组件部分："></a>父组件部分：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2048384-2abe089fb159740e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="f coms"></p>
<p>在调用组件的时候，使用 <code>v-bind</code> 将 logo 的值绑定为 App.vue 中定义的变量 logoMsg<br><img src="http://upload-images.jianshu.io/upload_images/2048384-93cc0135a3ae1872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="app com"></p>
<p>然后就能将App.vue中 logoMsg 的值传给 header.vue 了。</p>
<h3 id="二、子组件向父组件传递数据"><a href="#二、子组件向父组件传递数据" class="headerlink" title="二、子组件向父组件传递数据"></a>二、子组件向父组件传递数据</h3><p>子组件主要通过事件传递数据给父组件</p>
<h4 id="子组件部分：-1"><a href="#子组件部分：-1" class="headerlink" title="子组件部分："></a>子组件部分：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2048384-68e1276f01d214e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c com"></p>
<p>这是 login.vue 的 HTML 部分，当<code>&lt;input&gt;</code>的值发生变化的时候，将 username 传递给 App.vue</p>
<p>首先声明一个了方法setUser，用 keyup 事件来调用 setUser<br><img src="http://upload-images.jianshu.io/upload_images/2048384-794ef5254e0fb50a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c com"></p>
<p>在 setUser 中，使用了$emit来遍历transferUser事件，并返回 this.username</p>
<p>其中transferUser是一个自定义的事件，功能类似于一个中转，this.username将通过这个事件传递给父组件</p>
<h4 id="父组件部分：-1"><a href="#父组件部分：-1" class="headerlink" title="父组件部分："></a>父组件部分：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2048384-6e295b68c26f7d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="f com"></p>
<p>在父组件 App.vue 中，声明了一个方法 getUser，用 transferUser 事件调用 getUser 方法，获取到从子组件传递过来的参数 username<br><img src="http://upload-images.jianshu.io/upload_images/2048384-9b96cdc9d7400681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="app com"></p>
<p>getUser 方法中的参数 msg 就是从子组件传递过来的参数 username</p>
<h3 id="三、子组件向子组件传递数据"><a href="#三、子组件向子组件传递数据" class="headerlink" title="三、子组件向子组件传递数据"></a>三、子组件向子组件传递数据</h3><p>Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。</p>
<p>为了便于开发，Vue 推出了一个状态管理工具 <em>Vuex</em> ，可以很方便实现组件之间的参数传递。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.iwashere.cn/2017/07/27/vue1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/vue1/" itemprop="url">《Vue随笔》 （一）使用vue-cli搭建项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T16:50:11+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vue-cli 是一个官方发布 vue.js 项目脚手架，使用 vue-cli 可以快速创建 vue 项目，GitHub地址是: <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">https://github.com/vuejs/vue-cli</a></p>
<h3 id="一、-安装-node"><a href="#一、-安装-node" class="headerlink" title="一、 安装 node"></a>一、 安装 node</h3><p>首先需要安装node环境，可以直接到官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>下载安装包。</p>
<p>（中文官网<a href="http://nodejs.cn/" target="_blank" rel="external">http://nodejs.cn/</a>）</p>
<p>安装完成后，可以命令行工具中输入<code>node -v</code>和<code>npm -v</code>，如果能显示出版本号，就说明安装成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2048384-4df0ecfffc293186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="install node"></p>
<h3 id="二、安装-vue-cli"><a href="#二、安装-vue-cli" class="headerlink" title="二、安装 vue-cli"></a>二、安装 vue-cli</h3><p>安装好了 node，我们可以直接全局安装 vue-cli：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure></p>
<p>但是这种安装方式比较慢，推荐使用国内镜像来安装，所以我们先设置 cnpm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<p>如果安装失败，可以使用<code>npm cache clean</code>清理缓存，然后再重新安装。后面的安装过程中，如有安装失败的情况，也需要先清理缓存</p>
<p>同样可以使用<code>cnpm -v</code>查看是否安装成功</p>
<p>然后使用 cnpm 安装 vue-cli 和 webpack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g vue-cli</span><br></pre></td></tr></table></figure></p>
<p>最新的 vue 项目模板中，都带有 webpack 插件，所以这里可以不安装 webpack</p>
<p>安装完成后，可以使用<code>vue -V</code>（注意 V 大写）查看是否安装成功。</p>
<p>如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，可以使用 <code>npm install -g npm</code> 来更新版本</p>
<h3 id="三、生成项目"><a href="#三、生成项目" class="headerlink" title="三、生成项目"></a>三、生成项目</h3><p>首先需要在命令行中进入到项目目录，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack vue_project</span><br></pre></td></tr></table></figure></p>
<p>其中 webpack 是模板名称，可以到 vue.js 的 GitHub 上查看更多的模板<a href="https://github.com/vuejs-templates" target="_blank" rel="external">https://github.com/vuejs-templates</a></p>
<p>vue_project是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹<br><img src="http://upload-images.jianshu.io/upload_images/2048384-9713fb1cdcc1595a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="generate project"></p>
<p>配置完成后，可以看到目录下多出了一个项目文件夹，里面就是 vue-cli 创建的一个基于 webpack 的 vue.js 项目</p>
<p>然后进入项目目录（cd vue_project），使用 cnpm 安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure></p>
<p>然后启动项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p>
<p>如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件<code>config&gt;index.js</code><br><img src="http://upload-images.jianshu.io/upload_images/2048384-fce2e05adee67495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config"></p>
<p>建议将端口号改为不常用的端口。另外我还将 <code>build</code> 的路径前缀修改为 ‘ ./ ‘（原本为 ‘ / ‘），是因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。</p>
<h3 id="四、打包上线"><a href="#四、打包上线" class="headerlink" title="四、打包上线"></a>四、打包上线</h3><p>自己的项目文件都需要放到 <code>src</code> 文件夹下</p>
<p>项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></p>
<p>打包完成后，会生成 <code>dist</code> 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看</p>
<p>项目上线时，只需要将 <code>dist</code> 文件夹放到服务器就行了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Joseph" />
            
              <p class="site-author-name" itemprop="name">Joseph</p>
              <p class="site-description motion-element" itemprop="description">“为往圣继绝学”</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/qiaohongshen" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.jianshu.com/u/94698fea8055" target="_blank" title="简书">
                    
                      <i class="fa fa-fw fa-book"></i>简书</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joseph</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="200" alpha="0.6"  zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
